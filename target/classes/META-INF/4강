클래스 참고
Member4
Team4

4-1.
자바의 객체는 테이블의 구조와 다른점을 기억하자
테이블 같은 연관관계의 존재는 자바에는 없다.
자바는 참조를 통해 관계를 맺는다.

4-2.
참조관계에 있어서 이해해야 할 용어 3가지
1)방향: 단 /양
2)다중성 : 1:n , n:1, 1:1 ,n:n
3)연관관계의 주인

4-3.
orm을 쓰지 않으면 insert 나 select를 할 때 fk 식별자를 직접 제어해야 한다.
참고: pk가 반드시 설정이 된 다음에 영속상태가 된다.
참고: 그냥 @GeneratedValue를 하면 공통적인 시퀸스 풀(?) 을 쓰기 때문에 생성된 데이터는
     A테이블에서 1올라가고 B테이블에서 1올라가는 현상이 발생할 수 있다.

4-4.
단방향 매핑
테이블의 연관관계처럼 객체의 참조관계를 설정하려면
1) 테이블간 사이의 관계 (1:N,1:1....) 를 설정하고
2) join을 위한 칼럼을 설정해주면 된다.

4-5.
양방향 매핑
db에서 데이터베이스에서는 키와 키끼리 조인만하면 된다.
그리고 방향성이 존재하지 않는다.
어떻게 보면 방향성은 양쪽 다 가지고 있다.
테이블에서 fk와 pk를 조건으로 조인하는 경우가 그 예시이다.
orm에서도 이런 양방향관계를 설정을 하려면
양측에 서로를 참조할 수 있는 어떤 존재를 가지고 있어야한다.
1)
테이블 사이의 관계를 설정하고 mappedBy속성도 사용한다.
mappedBy는 joinColumn되어있는 필드라고 생각하면 쉬울것 같다.
2)
mappedBy
양방향 매핑은 그냥 단방향이 두개 존재하는것이다.
때문에 양방향 매핑관계에서는 어떤 문제가 발생한다.
만약에 Team테이블의 pk(team_id)를 fk(team_id)로 가지는 Member 테이블이 있다고 할 떄
jpa에서는 Team 클래스 List<Member> 타입 필드가 있고 Member클래스는 Team 타입 필드가 있다고 할떄
Member 클래스에서 team_id 를 update 해줘야될까
아니면 Team클래스에서 List<Member>를 update 해줘야될까
단방향이 두개라서 어떤걸 해도 db에서 동작하는 것처럼 동작은 가능하다.
그래서 어떤 룰을 정한다.
3)
Owener
룰은 Owner 즉, 주인을 정하는 것이다.
객체의 관계중 하나를 주인으로 지정하는 것이다.
주인은 외래키가 있는곳을 주인으로 하는걸 권장한다.
관관계의 주인만이 외래키를 관리한다(등록하거나 수정한다.)
주인이 아닌쪽은 읽기만 가능하다.(select)
주인은 mappedBy 속성을 사용하면 안된다. (= mappedBy가 있으면 주인이 아니다.)
주인이 아니면 mappedBy 속성으로 주인을 지정해 줘야만 한다.
4)
외래키 있는곳에 주인을 설정해야 되는이유
외래키가 있는곳이 대부분 N이다. 외래키가 pk인곳이 1이다.
DB에 N쪽에 연관관계의 주인이다.
db테이블로 따져서 N쪽이 주인이 되는게 좋다.
5)
유의점
연관관계의 주인인 클래스의 인스턴스에는 꼭 참조관계인 클래스 정보를 넣어주자.
6)
그래도 둘 다 정해줘야 한다.
양방향이라도 값을 양방향에 다 세팅을 해줘야 한다.
7)
그래서 아예 양방향에 값을 정해주는 메소드를 정해주자 (어느 한쪽이든)
대신 양쪽에 연관관계 편의 메소드를 정하지는 말자
자칫하면 무한루프 걸린다.
8)
양방향일시에는 무한루프 조심하자
ex)toString(), JSON생성 라이브러리, lombok
lombok일 경우에는 toString()을 쓰면 모든 필드에 대한 toString()을 만들어버린다.
근데 그러면 양쪽(1측과 N측)으로 toString()을 생성해버리고 서로 호출을 하기 때문에 무한루프가 걸린다.
JSON 라이브러리의 경우 JSON 자동 생성을 하는 경우에 문제가 되는데
Entity를 직접 controller 에서 response를 보낼때 Json parser가
toString 모냥 계속 양측을 번갈아하면서 파싱을 해버리는 경우가 생긴다.
9)
무한루프의 해결책
lombok의 경우에는 toString을 빼고 쓰자
Controller에서는 절대로 Entity를 반환하지 말자
Entity를 직접 반환할 때의 문제는 Entity는 변경될 수 있는데
Entity로 api를 반환을 해버리면 Entity가 바뀌는 것으로 api 스펙 자체가 바뀌어 버리는 것이다.
Entity는 Contoller에서 DTO로 변환을 한 다음에 사용하자(Entity값의 반환이든 입력이든)

4-6.
JPA로 설계를 하는 경우에는 처음에는 단방향 매핑으로 끝내도록 하자
양반향 매핑은 반대방향으로 조회 기능이 추가될때만 필요하다고 생각하자
역방향으로 탐색은 jpql로 많이 한다.
단방향 매핑을 잘해두면 양방향 매핑은 필요할때만 추가하면 된다. 테이블에 영향을 주는게 아니기 떄문







참고: 객체는 가급적 단방향 매핑이 좋다. 양방향으로 하면 신경쓸게 많아진다.


