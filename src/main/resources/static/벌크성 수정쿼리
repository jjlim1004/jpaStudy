엔티티의 데이터를 변경하면
더티체킹 = 변경감지 가 일어남
트랜잭션 커밋시점에 바뀐것에 대해 update 를 날림
근데 이건 한건한건 이루어진다.

그럼 다량에 데이터에 대한 걸 일괄적으로 update할때 쓰는 기능
== 벌크성 수정 쿼리

@Modifying 안할 경우 에러가 난다.
org.springframework.dao.InvalidDataAccessApiUsageException: org.hibernate.hql.internal.QueryExecutionRequestException: Not supported for DML operations [update study.datajpa.entity.Member m set m.age = m.age +1 where m.age >= :age]; nested exception is java.lang.IllegalStateException: org.hibernate.hql.internal.QueryExecutionRequestException: Not supported for DML operations [update study.datajpa.entity.Member m set m.age = m.age +1 where m.age >= :age]


/*********
주의점
jpa 는 영속성 컨텍스트가 entity를 관리한다.
하지만 벌크연산은 영속성 컨텍스트를 무시한다.

  //벌크 연산시 save 한 객체들은 영속성 컨텍스트에 있음
        //하지만 반영은 안되었음. db 에 반영이 안된상태 = commit이 안된 상태

        int resultCount = memberRepository.bulkAgePlus(20);
        //근데 이때 벌크연산을 하면 문제가 될 수 있다.
        //벌크연산 후에는 영속성 컨텍스트를 다 날려버려야 한다.

        em.flush();
        em.clear();
        //ex) 이렇게 조회하면 member5 의 age 는 41이 아닌 40이다.
        List<Member> result = memberRepository.findByUsername("member5");
        Member member5 = result.get(0);

/*********
mybatis, jdbc 등을 쓰면 영속성컨텍스트와 맞지 않을수 있다.
쿼리 날리기 전에 flush 하는게 좋고
많이 바뀌는게 있다 싶으면 clear 해주는게 좋다.
