1.
프록시에 대해서
1)
em.find 와 em.getReferences()
- em.find() : 데이터 베이스를 통해 실제 엔티티 객체를 조회한다.
- em.getReferences() : 데이터베이스 조회를 미루는 가짜(프록시) 엔티티 객체를 조회한다.
                        즉, db에 쿼리가 나가지 않는데도 조회를 한다.
2)
프록시는 엔티티객체를 상속한다.
프록시의 속성에는 target이라는 것이 있다.
이 target에는 상속을 한 엔티티객체의 정보를 가지고 있다.
프록시와 영속성과 db의 관계는 다음과 같다.
- 1. getUserName으로 userName을 쓰려고 한 시점에 영속성 컨텍스트에 요청을 한다.
     처음에 한번 초기화가 된다.
     이때 target의 값이 없으면 jpa는 영속성 컨텍스트에서 가져온다.
     영속성 컨텍스트에서 없다면 db에서 조회를 한다.
     조회된 결과를 토대로 entity를 만들고
     영속성컨텍스는 만들어진 entity 정보를 프록시에게 target의 값으로 준다.
     프록시 객체의 메소드 ( ex) getName() )은 상속한 클래스의 메소드를 사용하는 것이다.
3)
특징
- 1. 프록시 객체는 처음 사용할 때 한번 초기화 된다. 그 이후에 하지 않는다.
- 2. 프록시 객체를 초기화 할떄, 프록시 객체가 실제 엔티티로 바뀌는 게 아니다.
    접근 가능을 하게 만들어주는 것 뿐이다.
- 3. 따라서 타입 체크시에는 instance of 를 사용해야 된다. == 으로는 오류의 위험이 있다.
     타입이 프록시로 넘어오는건지, 엔티티로 넘어오는건지에 비교의 결과가 true가 될지 false가 될지 모른다.
- 4. 영속성 컨텍스트에 이미 엔티티가 있으면 getReference를 사용해도 엔티티를 가지고 온다.
     이미 1차 캐시에 있는 엔티티를 굳이 프록시를 사용해서 가져올 필요가 없어서다.
     그리고 jpa의 기본적인 원칙은 프록시 == entity는 같아야된다.
- 5. 준영속 상태일때 프록시 초기화를 하면 예외가 발생한다. LazyInitailiztionExceiption
4)
프록시에 대한 메소드
- 1. 초기화 여부 확인


2. 지연 로딩과 즉시 로딩
1)
연관관계가 있는 A와 B 엔티티가 있다고 하자
만약 A에만 있는 정보를 조회하고자 했을때 B까지 조회해버릴 필요는없다.
이때 사용하는게 지연로딩이다.
지연로딩은 @ManyToOne(fetch = FetchType.LAZY) 를 하면 사용이 가능하다.
지연로딩을 사용하면 조회를 할 시에 프록시 객체를 가지고 온다.
프록시의 초기화는 프록시로 가져오는 객체를 사용했을때 초기화가 된다.
2)
즉시로딩은 연관관계에 놓여있는 엔티티객체를 항시 같이 가져오는 것이다.
@ManyToOne(fetch = FetchType.EAGER) 를 사용다.
즉시로딩이기 때문에 프록시가 필요가 없다.
그냥 엔티티를 가지고 온다.
초기화도 필요가 없다. 프록시가 아니라 진짜 객체이기 때문
대부분의 JPA 구현체들은 EAGER 옵션을 기본으로 사용한다.
3)
그래도 가급적 지연로딩만을 사용하는게 좋다.
- 1 . 즉시로딩을 적용하면 예상치 못한 sql이 나올수도 있다.
     join이 수십개도 걸릴 수 있기 때문
- 2. jpql 에서 N+1 문제가 발생할 수 있다.
      N+1을 해결하기 위한 방법
      - Lazy로딩 설정 한다. 그리고 패치조인을 한다.(원하는 애들만 정해서 조인을 해준다.)
      - 엔티티그래프 어노테이션
      - 배치 사이즈
- 3. @ManyToOne , @OneToOne은 기본이 즉시로딩이기 때문에 Lazy로 설정하면 된다.
     @OneToMany , @ManyToMany는 기본이 지연로딩이다.


3.
영속성 전이
CASCADE
특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을때 사용한다.
persist를 할때 컬렉션 안에 있는 애들을 다 persist를 해준다는 어노테이션
연관관계 매핑과는 아무 관련이 없다.
영속화를 편리하게 하는것 이외의 기능은 없다.
오직 parent 와 child 만 관계가 있을때만 사용해야한다.
다른 엔티티와 child가 연관관계가 있으면 사용하면 안된다.

4.
고아객체
부모 엔티티와 연관관계가 끊어진 자식 엔티티를 자동으로 삭제한다.
대표적으로 remove할때가 그렇다.
@OneToMany(orphanRemoval = true)
참조하는 곳이 하나일때 사용해야한다.
@OneToOne, @OneToMany만 가능하다.
부모를 제거하면 자식객체도 제거가 된다. (db의 cascade와 비슷하다.)

5.
cascade + 고아객체
스스로 생명주기를 관리하는 엔티티는 em.persist로 영속화, em.remove()로 제거 할 수 있다.
이러면 부모 엔티티를 통해서 자식의 생명주기를 관리할 수 있다.
자식을 persist, remove 하지 않고 부모 객체의 생명주기만 제어하면 된다.




