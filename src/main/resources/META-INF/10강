10강

1.
용어의 정리
1)
상태필드
: 단순히 값을 저장하기 위한 필드
연관필드
: 연관관계를 위한 필드
   - 단일 값 연관필드 : 대상이 엔티티인것, 즉 뒤가 One
   - 컬렉션 값 연관필드 : 대상이 컬렉션인것, 즉 뒤가 Many
2)
탐색의 깊이
- 상태필드 : 경로 탐색의 끝 , 단순히 상태필드의 값만 선택된것
- 단일 값 연관필드 : 묵시적 내부조인이 일어난다. 탐색도 더 가능하다.
       예를들어
       select m.team.name From Member m
   - 이때 m.team이라는 필드를 쓰기 위해 Member 와 Team 간 묵시적 조인이 일어난다.
   - 쿼리 튜닝은 실무에서 중요한 부분이다.
   - 때문에 jpql을 쓸 때 묵시적 조인이 최대한 나지 않게 해야된다.
   - 어디서 묵시적 조인이 나는지 찾는지 어렵고, 튜닝하기도 어렵다.
- 컬렉션 값 연관필드 : 묵시적 내부조인이 일어난다. 탐색은 더 불가능하다.
       예를들어
       select t.members From Team t 에서
   - 이때 t.members 이라는 필드를 쓰기 위해 Member 와 Team 간 묵시적 조인이 일어난다.
   - 대신 // members.속성 // 은 불가능하다.
   - 이때 t.members.size 정도는 가능하다.
   - t.members 는 컬렉션으로 반환이 되기 때문이다. .을 써도 속성을 특정할 수 없다.
   - members 하위에 있는 속성들을 사용하고 싶다면 명시적 조인을 써야된다. 그러면 가능하다.
     명시적 조인을 사용하면 별칭을 가져올 수 있기 때문이다.
     ex) select m.username from Team t join t.members m
3)
주의점
되도록 묵시적 조인을 쓰면 안된다.
명시적 조인을 쓰자.
sql 튜닝은 join 이 중요한데 튜닝이 힘들다.
그리고 조인이 일어나는 상황도 파악하기 어렵다.
참고로 묵시적 조인은 내부 조인만 가능하다.
외부조인은 명시적 조인만 가능하다.

2.
페치조인
1)
페치 조인
-jpql 성능 최적화를 위한 기능
-연관된 엔티티나 컬렉션을 sql 한번에 함께 조회한다.
-join fetch 라는 키워드를 사용한다.
-즉시로딩과 똑같음
-쿼리를 명시적으로 동적인 타이밍에 한번에 조회할건지 정할 수 있다.
예시)
JPQL: select m from Member m join fetch m.team
SQL : select m.*,t.* from Member m  inner join Team t on m.team_id = t.id
2)
페치조인과 일반조인의 차이
-JPQL은 결과를 반환할 때 연관관계 고려를 하지 않는다.
-단지 select 절에 지정한 엔티티만 조회한다.
-페치조인을 사용할떄만 연관된 엔티티도 함꼐 조회한다. (= 즉시 로딩)
-페치조인은 객체 그래프를 sql 한번에 조회하는 개념이다.
-페치조인은 연관된 엔티티를 함께 조회한다.
3)
패치조인의 한계
- 패치조인 대상에는 별칭을 줄 수 없다.
  하이버네이트는 가능하다.
  별칭을 통해 경로표현식으로 부분적으로 탐색을 해 가져오다가,
  혹은 제어를 하다가 데이터가 잘못될 수 있기 때문. (정합성 이슈)
- 그나마 유일하게 별칭을 쓸때는 뒤에 또 join fetch를 쓸때
- 둘 이상의 컬렉션은 페치 조인 할 수 없다. (정합성 안맞을 수 있다.)
  (1:N 인 join fetch 를 계속하면 뻥튀기가 될 가능성이 높다.)
- 컬렉션 페치조인하면 페이징API를 하지 못한다.
  (1:1 , N:1은 페치 조인해도 괜찮다.)




