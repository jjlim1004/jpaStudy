9강. jpql

0
1) jpa 쿼리 지원
jpa는 다양한 쿼리 방법을 지원한다.
db에서 뭔가 트랜잭션을 하고자 할때 쿼리를 통해서 트랜잭션을 한다.
쿼리는 다양한 조인과 조건을 가질 수도 있다.
때문에 검색을 할 때를 예시로 들면 단순한 select 이외에도 복잡한 쿼리를 필요로 한다.
jpql: 표준 문법
jpa criteria : 자바코드로 짜서 jpql을 빌드해주는 클래스들
queryDSL
네이티브sql : 표준문법 이외의 쿼리, db 벤더에 종속적인 쿼리 ex) connect by
jdbc api 사용: mybatis 나 springJdbcTemplate등
대부분은 jpql로 해결이 되긴 하지만 안되는 경우에는 jpql외의 것도 같이 사용해도 된다.

2)
조회의 어려움에 따른 문제
가장 단순한 조회는
EntityManager.find()
혹은 그래프 탐색 ex) a.getB()
jpa는 객체로 테이블을 매핑하는것이다.
그리고 검색을 할 때에도 우리는 엔티티(객체)를 가지고 검색을 한다.
모든 db데이터를 객체로 변환해서 검색하는건 불가능하다.
검색을 할때 애플리케이션이 필요한 최소한의 데이터만 가지고 오는게 좋다.
결국 검색조건을 포함한 검색을 통한 필터링을 한 후에 데이터를 가지고 와야 한다.

3)
jpql
jpa에서 제공하는 객체 지향 쿼리언어(sql)
sql과 문법이 유사, select from where having group by 지원(ANSI 표준)
하지만 sql 과 달리 테이블이 대상으로 하는 쿼리가 아닌 객체를 대상으로 하는 쿼리 언어이다.
sql을 추상화하여 특정 데이터 베이스에 의존하지 않는다.
때문에 특정 db의 방언에 관계없이 원하는 쿼리가 db에 전달되어 실행이 된다.
jpql은 결국 sql에 변화되서 전달이 된다.

4)
criteria
createQuery 파라미터로 전달되는건 그냥 String
동적 쿼리를 쓰기 너무 힘들다.
문자열을 더하는 방식을 예로 들면 띄어쓰기, 쉼표 등을 신경써야한다.
동적 쿼리를 짜기 편하기 위한 대안으로 나온게 criteria다.
문자가 아니라 자바코드로 쿼리를 만들 수 있는 기능이다.
하지만 sql형식이 아니라서 보기가 너무 힘들다.
유지보수성이 떨어져서 실무에서는 많이 쓰지 않는다.
그래서 QueryDSL 사용을 권장한다.

5)
queryDSL
오픈소스이다.
문자가 아닌 자바코드로 jpql을 작성할 수 있음
jpql 빌더 역할을 해준다.
컴파일시 오류를 체크할 수 있다.
동적 쿼리 작성을 편하게 할 수 있다.
단순하고 쉬워서 실무사용이 권장된다.
그래도 jpql문법을 알고 queryDSL을 써야한다.
queryDSL은 편하게 사용할 수 있게 해주는 도구일 뿐이다.

6)
네이티브 jpql
네이티브 sql은 jpa가 제공하는 sql을 직접사용하는 기능이다.
jpql로는 해결할 수 특정 db벤더에 종속정인 쿼리를 처리할 수 있다.

7)
spring jdbcTemplate 나 마이바티스등을 함께 사용할 수 있다.
단, 영속성 컨텍스트를 적절한 시점에 강제로 flush 를 해야된다.
flush는 commit 했을때나 query가 날아갈때 flush가 자동적으로 된다.
createQuery 같은 경우에는 flush가 쿼리 날아가기 전에 flush가 되지만
jdbc connection을 가지고 쿼리를 처리할 경우 flush가 되지 않아 정상적인 처리가 안될 수 있다.


1.
jpql(java persistence query language)
1)
기본문법
다른게 없다. 특이한게 있다면 벌크연산(?)정도이다.
벌크연산은 한번에 여러가지의 값을 update하거나 delete 할 때 사용한다.
주의점은
- 엔티티와 속성은 대소문자를 구분한다. (객체에 있는 엔티티나 속성을 사용해야한다.)
- jpql 키워드 (select 나 from 같은 것들)은 대소문자를 구별하지 않는다.
- from 맨 뒤에 있는건 테이블이 아닌 엔티티의 이름이다.
- 엔티티의 별칭은 필수이다. as는 생략 가능하다.
- 집합과 정렬은 다 가능하다.
    ex) count, sum, avg, max, min등
        group by , having , distinct

2)
쿼리의 생성 메소드
typeQuery 와 Query
- 1. TypeQuery 는 반환타입이 명확할때 사용한다.
- 2. Query는 반환타입이 명확하지 않을떄 사용한다.

3)
쿼리의 결과 조회 메소드
getResultList 와 getSingleList
- 1. getResultList 는 컬렉션으로 반환을 한다. 즉, 값이 하나 이상일때 사용한다.
        결과가 없으면 빈 리스트를 반환한다.
- 2. getSingleList 한건만 있을때 사용한다.
        결과가 없으면 NoResultException이 발생한다.
        둘 이상이면 NonUniqueResultException이 발생한다.
     Spring Data JPA 에서는 결과가 없으면 exception 대신에 Optional로 처리하거나 null 로 처리한다.
     그래도 내부적으로는 try catch를 통해 예외를 검사해서 값을 반환해 주는것이다.

4)
파라미터 바인딩 메소드 체이닝도 가능하다.
- 이름에 따른 바인딩이 있고
- 위치에 따른 바인딩도 있다.
    위치에 따른 바인딩은 하지 않는게 좋다.
    파라미터 하나가 추가하면 뒤로 한칸씩 순서가 밀릴거고, 추가하면서 장애가 일어날 수 있다.



2.
프로젝션
select 절에 조회할 대상을 지정하는걸 말한다
프로젝션의 대상은 entity, 임베디드 타입, 스칼라 타입을 선택할 수 있다.
1)
유형
- select m from Member m 에서 m은 엔티티이다. => 엔티티 프로젝션
- select m.team from Member m => m.team 역시 엔티티이다. => 엔티티 프로젝션
- select m.address from Member m => m.address 는 임베디드 타입이다. => 임베디드 타입 프로젝션
- select m.username ,m.age from Member m => 스칼라 타입 프로젝션(일반적인 db 결과 나열)
- distinct 로 중복제거가 가능하다.

2)
스칼라 타입일때 조회하는 타입 3가지
-1. Query 타입으로 조회
-2. Object[] 타입으로 조회
-3. new 명령어로 조회



3.
페이징
mssql 과 오라클에 비해서 훨씬 편하다.
다음 두 api로 추상화를 했다.
- setFirstResult : 조회 시작 위치(0)부터 시작
- setMaxResult: 조회할 데이터 수 (몇번째 부터 몇개를 가져올 것인가)












