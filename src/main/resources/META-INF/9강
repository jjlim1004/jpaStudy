9강. jpql

0
1) jpa 쿼리 지원
jpa는 다양한 쿼리 방법을 지원한다.
db에서 뭔가 트랜잭션을 하고자 할때 쿼리를 통해서 트랜잭션을 한다.
쿼리는 다양한 조인과 조건을 가질 수도 있다.
때문에 검색을 할 때를 예시로 들면 단순한 select 이외에도 복잡한 쿼리를 필요로 한다.
jpql: 표준 문법
jpa criteria : 자바코드로 짜서 jpql을 빌드해주는 클래스들
queryDSL
네이티브sql : 표준문법 이외의 쿼리, db 벤더에 종속적인 쿼리 ex) connect by
jdbc api 사용: mybatis 나 springJdbcTemplate등
대부분은 jpql로 해결이 되긴 하지만 안되는 경우에는 jpql외의 것도 같이 사용해도 된다.

2)
조회의 어려움에 따른 문제
가장 단순한 조회는
EntityManager.find()
혹은 그래프 탐색 ex) a.getB()
jpa는 객체로 테이블을 매핑하는것이다.
그리고 검색을 할 때에도 우리는 엔티티(객체)를 가지고 검색을 한다.
모든 db데이터를 객체로 변환해서 검색하는건 불가능하다.
검색을 할때 애플리케이션이 필요한 최소한의 데이터만 가지고 오는게 좋다.
결국 검색조건을 포함한 검색을 통한 필터링을 한 후에 데이터를 가지고 와야 한다.

3)
jpql
jpa에서 제공하는 객체 지향 쿼리언어(sql)
sql과 문법이 유사, select from where having group by 지원(ANSI 표준)
하지만 sql 과 달리 테이블이 대상으로 하는 쿼리가 아닌 객체를 대상으로 하는 쿼리 언어이다.
sql을 추상화하여 특정 데이터 베이스에 의존하지 않는다.
때문에 특정 db의 방언에 관계없이 원하는 쿼리가 db에 전달되어 실행이 된다.
jpql은 결국 sql에 변화되서 전달이 된다.

4)
criteria
createQuery 파라미터로 전달되는건 그냥 String
동적 쿼리를 쓰기 너무 힘들다.
문자열을 더하는 방식을 예로 들면 띄어쓰기, 쉼표 등을 신경써야한다.
동적 쿼리를 짜기 편하기 위한 대안으로 나온게 criteria다.
문자가 아니라 자바코드로 쿼리를 만들 수 있는 기능이다.
하지만 sql형식이 아니라서 보기가 너무 힘들다.
유지보수성이 떨어져서 실무에서는 많이 쓰지 않는다.
그래서 QueryDSL 사용을 권장한다.

5)
queryDSL
오픈소스이다.
문자가 아닌 자바코드로 jpql을 작성할 수 있음
jpql 빌더 역할을 해준다.
컴파일시 오류를 체크할 수 있다.
동적 쿼리 작성을 편하게 할 수 있다.
단순하고 쉬워서 실무사용이 권장된다.
그래도 jpql문법을 알고 queryDSL을 써야한다.
queryDSL은 편하게 사용할 수 있게 해주는 도구일 뿐이다.

6)
네이티브 jpql
네이티브 sql은 jpa가 제공하는 sql을 직접사용하는 기능이다.
jpql로는 해결할 수 특정 db벤더에 종속정인 쿼리를 처리할 수 있다.

7)
spring jdbcTemplate 나 마이바티스등을 함께 사용할 수 있다.
단, 영속성 컨텍스트를 적절한 시점에 강제로 flush 를 해야된다.
flush는 commit 했을때나 query가 날아갈때 flush가 자동적으로 된다.
createQuery 같은 경우에는 flush가 쿼리 날아가기 전에 flush가 되지만
jdbc connection을 가지고 쿼리를 처리할 경우 flush가 되지 않아 정상적인 처리가 안될 수 있다.


1.
jpql(java persistence query language)
1)
기본문법
다른게 없다. 특이한게 있다면 벌크연산(?)정도이다.
벌크연산은 한번에 여러가지의 값을 update하거나 delete 할 때 사용한다.
주의점은
- 엔티티와 속성은 대소문자를 구분한다. (객체에 있는 엔티티나 속성을 사용해야한다.)
- jpql 키워드 (select 나 from 같은 것들)은 대소문자를 구별하지 않는다.
- from 맨 뒤에 있는건 테이블이 아닌 엔티티의 이름이다.
- 엔티티의 별칭은 필수이다. as는 생략 가능하다.
- 집합과 정렬은 다 가능하다.
    ex) count, sum, avg, max, min등
        group by , having , distinct

2)
쿼리의 생성 메소드
typeQuery 와 Query
- 1. TypeQuery 는 반환타입이 명확할때 사용한다.
- 2. Query는 반환타입이 명확하지 않을떄 사용한다.

3)
쿼리의 결과 조회 메소드
getResultList 와 getSingleList
- 1. getResultList 는 컬렉션으로 반환을 한다. 즉, 값이 하나 이상일때 사용한다.
        결과가 없으면 빈 리스트를 반환한다.
- 2. getSingleList 한건만 있을때 사용한다.
        결과가 없으면 NoResultException이 발생한다.
        둘 이상이면 NonUniqueResultException이 발생한다.
     Spring Data JPA 에서는 결과가 없으면 exception 대신에 Optional로 처리하거나 null 로 처리한다.
     그래도 내부적으로는 try catch를 통해 예외를 검사해서 값을 반환해 주는것이다.

4)
파라미터 바인딩 메소드 체이닝도 가능하다.
- 이름에 따른 바인딩이 있고
- 위치에 따른 바인딩도 있다.
    위치에 따른 바인딩은 하지 않는게 좋다.
    파라미터 하나가 추가하면 뒤로 한칸씩 순서가 밀릴거고, 추가하면서 장애가 일어날 수 있다.



2.
프로젝션
select 절에 조회할 대상을 지정하는걸 말한다
프로젝션의 대상은 entity, 임베디드 타입, 스칼라 타입을 선택할 수 있다.
1)
유형
- select m from Member m 에서 m은 엔티티이다. => 엔티티 프로젝션
- select m.team from Member m => m.team 역시 엔티티이다. => 엔티티 프로젝션
- select m.address from Member m => m.address 는 임베디드 타입이다. => 임베디드 타입 프로젝션
- select m.username ,m.age from Member m => 스칼라 타입 프로젝션(일반적인 db 결과 나열)
- distinct 로 중복제거가 가능하다.

2)
스칼라 타입일때 조회하는 타입 3가지
-1. Query 타입으로 조회
-2. Object[] 타입으로 조회
-3. new 명령어로 조회



3.
페이징
mssql 과 오라클에 비해서 훨씬 편하다.
다음 두 api로 추상화를 했다.
- setFirstResult : 조회 시작 위치(0)부터 시작
- setMaxResult: 조회할 데이터 수 (몇번째 부터 몇개를 가져올 것인가)
만약에 오라클로 dialect 로 설정이 되어있다면
오라클 형식에 맞춘 페이징 쿼리 처리를 해준다.

4.
조인
1)
내부조인
sql의 조인과 비슷하게 조인이 된다.
대신에 엔티티를 중심으로 조인이 실행된다.
select m FROM Member m (inner)join m.team t
객체이기 때문에 m.team 처럼 .이 쓰인다.
2)
외부조인
select m FROM Member m LEFT (OUTER)JOIN m.team t
3)
세타조인(연관관계가 없는 것끼리 조인을 하는것)
select count(m) from Member m , Team t where m.username = t.name

4)
on 절
- 조인대상 필터링의 기능
- 연관관계가 없는 엔티티 외부 조인이 가능(하이버네이트 5.1부터)
   참고로 지금 쓰는건 왠만하면 5.1이상
   이전에는 inner join 만 했었지만
   이제는 연관관계가 없는 엔티티와도 outer join을 할 수 있다.
   - select m ,t from Member m Left join Team t on m.username =t.name
   연관관계가 전혀없는것을 left join 하고 싶을때 on을 사용할 수 있다.



5.
서브쿼리
일반적인 서브쿼리랑 거의 비슷하다.
참고로. sql의 내용이지만 any,some 은 부등호를 사용할 수 있지만 in은 불가능하다.
- 서브쿼리 지원함수
    -1. exists  :서브쿼리가 존재하면 참
        all ,any ,some 을 사용할 수 있다.
        all 은 모두 만족하면 참
        any, some 은 조건을 하나라도 만족하면 참이다.
    -2. in은 하나라도 같은것이 있으면 참

- jpa 표준은 where 절과 having절에서만 서브쿼리를 사용 가능하다.
- 하이버네이트에서는 select 절에서도 서브쿼리가 가능
- 하지만 from 절의 서브쿼리 (인라인뷰) 는 현재 jpql에서 불가능하다.
  조인에서 풀 수 있으면 조인으로 해결해야된다.
  아니면 쿼리를 두번 날린다거나, native query를 써야한다.
  어플리케이션에서 해결해야하거나.


6.
jpql의 타입표현
1)
문자는 '' 안에 넣어야한다.
' 가 필요하면 '를 두번 넣어야한다. 'she''s' == she's
2)
숫자는 10L , 10D, 10F 처럼 넣어야한다.
3)
ENUM은 패키지명까지 다 포함해야한다.
타입 파라미터로 보내면 좀 더 수월하다.
쿼리dsl에서는 자바코드로 제어하기 때문에 임포트를해서 쓸 수 있다고 한다
4)
엔티티 타입
상속관계에서 사용이 된다.
타입 캐스팅과 비슷한 느낌이다.
type(m) = Member


7.
조건식
아래에 있는 식들은 jpa 표준식이다.
1)
case식( 기본 case 식, 단순 case 식)
queryDSL을 쓰면 자바코드로 작성할 수 있다. 결국 자바코드가 빌드되어 쿼리가 만들어진다.
문자로 작성하는데 너무 힘들다. 오류가 몇번 난다.
인텔리 제이 무료판 쓰니까 너무 힘들다.
2)
coalesce :하나씩 조회해서 null이 아니면 반환
3)
nullif(a,b) : 두 값이 같으면 null 반환, 다르면 첫번째값 반환
a와 b가 같으면 null
그냥 a가 null이면 그냥 null인듯


8.
jpql기본함수
사용가능한 함수의 종류는 3가지로 분류할 수 있다.
-1. jpql이 제공하는 표준함수
    데이터베이스에 상관없이 그냥 써도 되는 함수 ex) concat, substring...
    근데 표준함수에서 안된다... 싶으면 사용자 정의함수를 쓴다.
    - size 함수는 컬렉션의 size를 알고 싶을때 쓴다.
    - index는 jpa에서 사용한다.
       컬렉션의 위치값(index)을 알 수 있다.

-2. 사용자 정의 함수
    사용자 정의함수인지 아닌지 jpql은 알 방법이 없다.
    그래서 사용자 정의 함수를 쓸 수 있는 표준이 있다.
    하이버네이트는 사용전에 사용하는db(방언)에 추가해야한다.


-3. db종속적이긴하지만 db에 종속정인 함수가 정의가 되어있다.
    Oracle8Dialect.class 같은곳에서 찾을 수 있다.










