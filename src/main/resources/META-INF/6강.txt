0.
데이터 베이스에는 상속이라는 존재가 없다.
그나마 비슷한건 슈퍼타입-서브타입의 모델링이 있다.
1)
슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법은 3가지가 있다.
- 조인전략 (상위 하위 논리 모델을 연관관계를 가지게 하는 것으로 조인으로 조회)
- 단일 테이블 전략(논리 모델을 하나로 통일)
- 구현클래스마다 테이블을 만들기
어떤 방법을 쓰든 JPA에서는 다 구현이 가능하다.

1.
1)
조인전략
부모클래스의 엔티티에
@Inheritance(strategy = InheritanceType = joined)
를 쓰면 조인전략의 설계처럼 매핑이 된다.
2)
단일테이블 전략
@Inheritance(strategy = InheritanceType = SINGLE_TABLE)
을 쓰면 된다.
3)
1- 구현 클래스마다 테이블 전략
2- Item item = em.find(Item.class , movie.getId());
    객체지향적으로 생각하면 Item으로도 Movie 를 조회할 수 있어야한다.
    각각테이블 전략은 조회를 할때 모든테이블을 조회하고
    그 조회 결과를 union all 로 찾아온다.
    즉 성능에 영향이 있을 수 있다.

2.
장단점
1)
조인전략
1-장점
- 테이블 정규화가 되어있다.
- 외래키를 사용할 수 있다. 부모의 pk만 조회해도 조회가 가능하다.
- 저장공간을 효율적으로 사용할 수 있다.
2-단점
- 조인을 사용하기 때문에 쿼리가 복잡하거나 성능이 약간 떨어질 수 있다.
- 데이터 저장시 저장 sql 쿼리가 두번 호출된다.
2)
단일테이블 전략
1-장점
- 조인이 필요없다. 조회가 빠르다.
2-단점
- 자식 엔티티가 매핑한 칼럼은 모두 null을 허용해야만 한다.
- 테이블이 커짐으로 인해 조회성능이 느려질 수 있다.
3)
구현클래스마다 테이블전략(각각 테이블전략)
-쓰면 안되는 저주받은 모델링
1-장점
- not null 제약조건을 활용가능은하다.
2-단점
- 여러 자식 테이블을 함께 조회할 때 union all 을 써서 성능이 저하 될 수 있다.
- 새로운 칼럼이 추가가 될때 모델링한 자를 저주하게 될 것이다. 모든 테이블에 칼럼을 추가해야 될것이다.
- 자식 테이블과 통합하기도 힘들다.
