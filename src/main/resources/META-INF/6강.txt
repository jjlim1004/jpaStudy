0.
데이터 베이스에는 상속이라는 존재가 없다.
그나마 비슷한건 슈퍼타입-서브타입의 모델링이 있다.
1)
슈퍼타입 서브타입 논리 모델을 실제 물리 모델로 구현하는 방법은 3가지가 있다.
- 조인전략 (상위 하위 논리 모델을 연관관계를 가지게 하는 것으로 조인으로 조회)
- 단일 테이블 전략(논리 모델을 하나로 통일)
- 구현클래스마다 테이블을 만들기
어떤 방법을 쓰든 JPA에서는 다 구현이 가능하다.

1.
1)
조인전략
부모클래스의 엔티티에
@Inheritance(strategy = InheritanceType = joined)
를 쓰면 조인전략의 설계처럼 매핑이 된다.
2)
단일테이블 전략
@Inheritance(strategy = InheritanceType = SINGLE_TABLE)
을 쓰면 된다.
3)
1- 구현 클래스마다 테이블 전략
2- Item item = em.find(Item.class , movie.getId());
    객체지향적으로 생각하면 Item으로도 Movie 를 조회할 수 있어야한다.
    각각테이블 전략은 조회를 할때 모든테이블을 조회하고
    그 조회 결과를 union all 로 찾아온다.
    즉 성능에 영향이 있을 수 있다.

2.
장단점
1)
조인전략
1-장점
- 테이블 정규화가 되어있다.
- 외래키를 사용할 수 있다. 부모의 pk만 조회해도 조회가 가능하다.
- 저장공간을 효율적으로 사용할 수 있다.
2-단점
- 조인을 사용하기 때문에 쿼리가 복잡하거나 성능이 약간 떨어질 수 있다.
- 데이터 저장시 저장 sql 쿼리가 두번 호출된다.
2)
단일테이블 전략
1-장점
- 조인이 필요없다. 조회가 빠르다.
2-단점
- 자식 엔티티가 매핑한 칼럼은 모두 null을 허용해야만 한다.
- 테이블이 커짐으로 인해 조회성능이 느려질 수 있다.
3)
구현클래스마다 테이블전략(각각 테이블전략)
-쓰면 안되는 저주받은 모델링
1-장점
- not null 제약조건을 활용가능은하다.
2-단점
- 여러 자식 테이블을 함께 조회할 때 union all 을 써서 성능이 저하 될 수 있다.
- 새로운 칼럼이 추가가 될때 모델링한 자를 저주하게 될 것이다. 모든 테이블에 칼럼을 추가해야 될것이다.
- 자식 테이블과 통합하기도 힘들다.


3.
1)
DB는 각각의 테이블이지만
객체로 표현시에 같은 속성이 많아
부모 클래스를 만든 뒤 상속을 통해 공통적으로 사용하려고 할 때 사용한다.
2)
@MappedSupperClass 는 정의한 부모클래스에 정의를 한다.
3)
부모클래스의 필드에도 @Column 정의가 가능하다.
4)
테이블로 매핑되지 않는다.
그렇기 때문에 부모타입으로 조회가 안된다.
테이블 자체도 없기 때문.
직접 생성할 일이 없다. 때문에 추상클래스로 만드는걸 추천한다.
